// abraham_knowledge_db.c
// Compile: gcc -O3 -o abraham_knowledge_db abraham_knowledge_db.c -lsqlite3
// Usage examples:
//   ./abraham_knowledge_db init
//   ./abraham_knowledge_db add "Path" "From Ur to Canaan via Haran" "Genesis 11:31–12:5"
//   ./abraham_knowledge_db search "Ur"
//   ./abraham_knowledge_db report
// v0.1.0

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sqlite3.h>

static int callback(void *NotUsed, int argc, char **argv, char **azColName) {
    for (int i = 0; i < argc; i++) {
        printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}

void init_db() {
    sqlite3 *db;
    char *err = 0;
    if (sqlite3_open("abraham_knowledge.db", &db) != SQLITE_OK) {
        fprintf(stderr, "Cannot open DB: %s\n", sqlite3_errmsg(db));
        return;
    }

    const char *sql =
        "CREATE TABLE IF NOT EXISTS knowledge ("
        "  category TEXT NOT NULL,"
        "  content TEXT NOT NULL,"
        "  references TEXT,"
        "  added_at TEXT DEFAULT CURRENT_TIMESTAMP,"
        "  PRIMARY KEY (category, content)"
        ");";

    if (sqlite3_exec(db, sql, 0, 0, &err) != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err);
        sqlite3_free(err);
    } else {
        printf("Knowledge DB initialized.\n");
    }
    sqlite3_close(db);
}

void add_entry(const char *category, const char *content, const char *refs) {
    sqlite3 *db;
    char *err = 0;
    if (sqlite3_open("abraham_knowledge.db", &db) != SQLITE_OK) return;

    char *sql = sqlite3_mprintf(
        "INSERT OR IGNORE INTO knowledge (category, content, references) VALUES (%Q, %Q, %Q);",
        category, content, refs ? refs : ""
    );

    if (sqlite3_exec(db, sql, 0, 0, &err) != SQLITE_OK) {
        fprintf(stderr, "Insert error: %s\n", err);
        sqlite3_free(err);
    } else {
        printf("Added: %s → %s\n", category, content);
    }
    sqlite3_free(sql);
    sqlite3_close(db);
}

void search(const char *term) {
    sqlite3 *db;
    char *err = 0;
    if (sqlite3_open("abraham_knowledge.db", &db) != SQLITE_OK) return;

    char *sql = sqlite3_mprintf(
        "SELECT category, content, references FROM knowledge "
        "WHERE content LIKE '%%%q%%' OR category LIKE '%%%q%%' OR references LIKE '%%%q%%';",
        term, term, term
    );

    if (sqlite3_exec(db, sql, callback, 0, &err) != SQLITE_OK) {
        fprintf(stderr, "Search error: %s\n", err);
        sqlite3_free(err);
    }
    sqlite3_free(sql);
    sqlite3_close(db);
}

void report() {
    sqlite3 *db;
    char *err = 0;
    if (sqlite3_open("abraham_knowledge.db", &db) != SQLITE_OK) return;

    const char *sql = "SELECT category, COUNT(*) AS entries FROM knowledge GROUP BY category ORDER BY entries DESC;";
    if (sqlite3_exec(db, sql, callback, 0, &err) != SQLITE_OK) {
        fprintf(stderr, "Report error: %s\n", err);
        sqlite3_free(err);
    }
    sqlite3_close(db);
}

int main(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage:\n"
               "  init\n"
               "  add <category> <content> [references]\n"
               "  search <term>\n"
               "  report\n");
        return 1;
    }

    if (strcmp(argv[1], "init") == 0) {
        init_db();
    } else if (strcmp(argv[1], "add") == 0 && argc >= 4) {
        add_entry(argv[2], argv[3], argc > 4 ? argv[4] : NULL);
    } else if (strcmp(argv[1], "search") == 0 && argc == 3) {
        search(argv[2]);
    } else if (strcmp(argv[1], "report") == 0) {
        report();
    } else {
        printf("Unknown command.\n");
        return 1;
    }

    return 0;
}